<script src="https://unpkg.com/@tensorflow/tfjs-core@2.4.0/dist/tf-core.js"></script>
<script src="https://unpkg.com/@tensorflow/tfjs-converter@2.4.0/dist/tf-converter.js"></script>
<script src="https://unpkg.com/@tensorflow/tfjs-backend-webgl@2.4.0/dist/tf-backend-webgl.js"></script>
<script src="https://unpkg.com/@tensorflow-models/face-landmarks-detection@0.0.1/dist/face-landmarks-detection.js">
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.js"></script>


<pre>score: 0</pre>



<script>
	const pre = document.querySelector('pre');
	let capture;
	let predictions = []
	let score = 0


	class Grabber {
		mouthOpen = false // boolean
		dragging = null // A SceneObject
		inRange = null // A SceneObject
		justReleased = null // A SceneObject
		justOpened = false
		justClosed = false
	}

	let grabbers = [
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber()
	]


	let objectsToGrab = [{
		x: 100,
		y: 100,
		r: 50
	}]


	let dropZones = [
		// {x: 300, y: 300, r: 150}
	]


	function setup() {
		createCanvas(640, 480);
		capture = createCapture(VIDEO);
		capture.size(640, 480);
		capture.hide();


		(async () => {
			const model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages
				.mediapipeFacemesh, {
					maxFaces: 4,
					shouldLoadIrisModel: false
				});

			setInterval(async () => {
				predictions = await model.estimateFaces({
					input: capture.elt,
					predictIrises: false
				});
			}, 5)
		})()

	}

	function draw() {
		background(255);

		translate(capture.width, 0);
		scale(-1, 1);
		image(capture, 0, 0, 640, 480);
		noStroke()


		for (let i = 0; i < predictions.length; i++) {
			const p = predictions[i];
			const g = grabbers[i];
			const [mouthX, mouthY, mouthZ] = p.annotations.lipsLowerInner[5]

			g.justClosed = false
			g.justOpened = false

			// Update 
			const difference = p.annotations.lipsLowerInner[5][1] - p.annotations.lipsUpperInner[5][1]

			let lastMouthOpen = g.mouthOpen
			g.mouthOpen = difference > 10

			if (lastMouthOpen && !g.mouthOpen) {
				g.justClosed = true
				g.justOpened = false
			} else if (!lastMouthOpen && g.mouthOpen) {
				g.justOpened = true
				g.justClosed = false
			}



			let anyInRange = false

			for (const o of objectsToGrab) {
				if (distance(mouthX, mouthY, o.x, o.y) < o.r / 2) {
					g.inRange = o
					anyInRange = true

					if (g.justClosed && g.mouthOpen == false) {
						g.dragging = o
					}


				}



				if (g.dragging == o) {
					o.x = lerp(mouthX, o.x, 0.5)
					o.y = lerp(mouthY, o.y, 0.5)
				}
			}

			if (g.mouthOpen) {
				g.dragging = null
			}

			console.log(g)



			if (!anyInRange) {
				g.inRange = null
			}


			// Draw
			fill(g.mouthOpen ? 'white' : 'cyan')

			const a = p.annotations.lipsLowerInner[5]
			ellipse(a[0], a[1], 20)

			const b = p.annotations.lipsUpperInner[5]
			ellipse(b[0], b[1], 20)
		}


		for (const o of objectsToGrab) {
			fill('red')
			ellipse(o.x, o.y, o.r)
		}

		for (const d of dropZones) {
			fill('rgba(255,255,255,0.5)')
			ellipse(d.x, d.y, d.r)

			for (const o of objectsToGrab) {
				if (distance(d.x, d.y, o.x, o.y) < d.r / 2) {
					objectsToGrab = objectsToGrab.filter(oo => oo != o)
					score += 1
					pre.innerHTML = `score: ${score}`

					objectsToGrab.push({
						x: random(capture.width),
						y: random(capture.height),
						r: 50
					})
				}
			}
		}
	}


	function distance(x1, y1, x2, y2) {
		return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
	}
</script>

<style>
	body {
		margin: 0;
	}

	video {
		width: 1080;
		display: none;
	}

	canvas {
		width: 100vw !important;
		height: unset !important;
	}
</style>