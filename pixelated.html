<head>
	<script src="https://unpkg.com/@tensorflow/tfjs-core@2.4.0/dist/tf-core.js"></script>
	<script src="https://unpkg.com/@tensorflow/tfjs-converter@2.4.0/dist/tf-converter.js"></script>
	<script src="https://unpkg.com/@tensorflow/tfjs-backend-webgl@2.4.0/dist/tf-backend-webgl.js"></script>
	<script src="https://unpkg.com/@tensorflow-models/face-landmarks-detection@0.0.1/dist/face-landmarks-detection.js">
	</script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.js"></script>
</head>


<script>
	const pre = document.querySelector('pre');
	let capture;
	let predictions = []
	let score = 0

	const WIDTH = 160
	const HEIGHT = 120


	class MouthParticle {
		r = 0

		constructor(x, y) {
			this.x = x
			this.y = y
		}

		update() {
			this.r++
		}

		draw() {
			stroke('red')
			noFill()
			// fill(`rgba(255,0,0,${Math.max(1 - this.r / 20, 0)})`)
			ellipse(this.x, this.y, this.r)
		}
	}


	class Grabber {
		mouthOpen = false // boolean
		dragging = null // A SceneObject
		inRange = null // A SceneObject
		justReleased = null // A SceneObject
		justOpened = false
		justClosed = false
		mouthParticles = []

		update() {

		}

		draw() {

		}
	}

	let grabbers = [
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber()
	]


	let objectsToGrab = [{
		x: 50,
		y: 50,
		r: 10
	}]


	let dropZones = [
		// {x: 300, y: 300, r: 150}
	]


	function setup() {
		createCanvas(WIDTH, HEIGHT);
		capture = createCapture(VIDEO);
		capture.size(640, 480);
		capture.hide();


		(async () => {
			const model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages
				.mediapipeFacemesh, {
					maxFaces: 4,
					shouldLoadIrisModel: false
				});

			setInterval(async () => {
				predictions = await model.estimateFaces({
					input: capture.elt,
					predictIrises: false
				});
			}, 5)
		})()

	}

	function draw() {
		background(255);
		translate(WIDTH, 0);
		scale(-1, 1);
		image(capture, 0, 0, WIDTH, HEIGHT);
		filter(THRESHOLD)
		noStroke()


		for (let i = 0; i < predictions.length; i++) {
			const p = predictions[i];
			const g = grabbers[i];
			const coords = p.annotations.lipsLowerInner[5]
			const mouthX = coords[0] / 4
			const mouthY = coords[1] / 4
			const upperLipsY = p.annotations.lipsUpperInner[1] / 4
			const middleMouthY = (mouthY + p.annotations.lipsUpperInner[5][1] / 4) / 2
			const mouthZ = coords[2] / 4

			g.justClosed = false
			g.justOpened = false

			// Update 
			const difference = p.annotations.lipsLowerInner[5][1] - p.annotations.lipsUpperInner[5][1]

			let lastMouthOpen = g.mouthOpen
			g.mouthOpen = difference > 10

			if (lastMouthOpen && !g.mouthOpen) {
				g.justClosed = true
				g.justOpened = false
			} else if (!lastMouthOpen && g.mouthOpen) {
				g.justOpened = true
				g.justClosed = false
			}



			let anyInRange = false

			for (const o of objectsToGrab) {
				if (distance(mouthX, mouthY, o.x, o.y) < o.r / 2) {
					g.inRange = o
					anyInRange = true

					if (g.justClosed && g.mouthOpen == false) {
						g.dragging = o
					}
				}



				if (g.dragging == o) {
					o.x = lerp(mouthX, o.x, 0.5)
					o.y = lerp(mouthY, o.y, 0.5)
				}
			}

			if (g.mouthOpen) {
				g.dragging = null

				if (frameCount % 30 == 0) {
					console.log("spawn!!")
					g.mouthParticles.push(new MouthParticle(mouthX, middleMouthY))
				}
			}

			for (const particle of g.mouthParticles) {
				particle.update()
				particle.draw()

				if (particle.r > 50) {
					console.log('should destroy')
					g.mouthParticles = g.mouthParticles.filter(p => p != particle)
				}
			}


			if (!anyInRange) {
				g.inRange = null
			}


			// Draw
			fill(g.mouthOpen ? 'white' : 'cyan')
			noStroke()

			const a = p.annotations.lipsLowerInner[5]
			ellipse(a[0] / 4, a[1] / 4, 5)

			const b = p.annotations.lipsUpperInner[5]
			ellipse(b[0] / 4, b[1] / 4, 5)
		}


		for (const o of objectsToGrab) {
			fill('red')
			ellipse(o.x, o.y, o.r)
		}

		for (const d of dropZones) {
			fill('rgba(255,255,255,0.5)')
			ellipse(d.x, d.y, d.r)

			for (const o of objectsToGrab) {
				if (distance(d.x, d.y, o.x, o.y) < d.r / 2) {
					objectsToGrab = objectsToGrab.filter(oo => oo != o)
					score += 1
					pre.innerHTML = `score: ${score}`

					objectsToGrab.push({
						x: random(capture.width),
						y: random(capture.height),
						r: 50
					})
				}
			}
		}
	}


	function distance(x1, y1, x2, y2) {
		return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
	}
</script>

<style>
	body {
		margin: 0;
	}

	video {
		width: 1080;
		display: none;
	}

	canvas {
		width: 100vw !important;
		height: unset !important;
		image-rendering: pixelated;
	}
</style>