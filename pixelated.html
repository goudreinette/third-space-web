<head>
	<script src="./lib/tf-core.js"></script>
	<script src="./lib/tf-converter.js"></script>
	<script src="./lib/tf-backend-webgl.js"></script>
	<script src="./lib/face-landmarks-detection.js"></script>
	<script src="./lib/p5.js"></script>
</head>


<script>
	let capture;
	let predictions = []
	let score = 0

	const WIDTH = 160
	const HEIGHT = 120


	class MouthParticle {
		r = 0

		constructor(x, y, grabber) {
			this.x = x
			this.y = y
			this.grabber = grabber
		}

		update() {
			this.r++
		}

		draw() {
			stroke('red')
			noFill()
			// fill(`rgba(255,0,0,${Math.max(1 - this.r / 20, 0)})`)
			ellipse(this.x, this.y, this.r)
		}
	}

	class DropZone {
		constructor(x, y, r) {
			this.x = x
			this.y = y
			this.r = r
		}

		update() {
			for (const o of objectsToGrab) {
				if (distance(this.x, this.y, o.x, o.y) < this.r / 2) {
					objectsToGrab = objectsToGrab.filter(oo => oo != o)
					score += 1

					// Spawn a new one
					objectsToGrab.push({
						x: random(WIDTH),
						y: random(HEIGHT),
						r: 10
					})
				}
			}
		}

		draw() {
			fill('rgba(255,255,255,0.5)')
			noStroke()
			ellipse(this.x, this.y, this.r)
		}
	}


	class Grabber {
		x = 0
		y = 0

		mouthOpen = false // boolean
		dragging = null // A SceneObject
		inRange = null // A SceneObject
		justReleased = null // A SceneObject
		justOpened = false
		justClosed = false
		mouthParticles = []

		update(prediction) {
			const {
				lipsLowerInner,
				lipsUpperInner
			} = prediction.annotations

			// Calculate positions
			const lipsLowerInnerCoords = lipsLowerInner[5]
			const lipsUpperInnerCoords = lipsUpperInner[5]
			const lowerLipsY = lipsLowerInnerCoords[1] / 4
			const upperLipsY = lipsUpperInnerCoords[1] / 4

			const mouthX = this.x = lipsLowerInnerCoords[0] / 4
			const mouthY = this.y = (lowerLipsY + upperLipsY) / 2
			const mouthZ = lipsLowerInnerCoords[2] / 4

			// Update 
			this.justClosed = false
			this.justOpened = false

			const difference = lipsLowerInner[5][1] - lipsUpperInner[5][1]

			let lastMouthOpen = this.mouthOpen
			this.mouthOpen = difference > 10

			if (lastMouthOpen && !this.mouthOpen) {
				this.justClosed = true
				this.justOpened = false
			} else if (!lastMouthOpen && this.mouthOpen) {
				this.justOpened = true
				this.justClosed = false
			}

			let anyInRange = false

			for (const o of objectsToGrab) {
				if (distance(mouthX, lowerLipsY, o.x, o.y) < o.r / 2) {
					this.inRange = o
					anyInRange = true

					if (this.justClosed && this.mouthOpen == false) {
						this.dragging = o
					}
				}

				if (this.dragging == o) {
					o.x = lerp(mouthX, o.x, 0.25)
					o.y = lerp(lowerLipsY, o.y, 0.25)
				}
			}

			if (this.mouthOpen) {
				this.dragging = null

				if (frameCount % 5 == 0) {
					this.mouthParticles.push(new MouthParticle(mouthX, mouthY))
				}
			}

			for (const particle of this.mouthParticles) {
				particle.update()
				if (particle.r > 20) {
					this.mouthParticles = this.mouthParticles.filter(p => p != particle)
				}
			}

			if (!anyInRange) {
				this.inRange = null
			}
		}

		draw() {
			// Draw
			for (const particle of this.mouthParticles) {
				particle.draw()
			}
		}
	}

	let grabbers = [
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber(),
		new Grabber()
	]


	let objectsToGrab = [{
		x: 50,
		y: 50,
		r: 10
	}]


	let dropZones = [
		new DropZone(80, 80, 10)
	]


	function setup() {
		createCanvas(WIDTH, HEIGHT);
		capture = createCapture(VIDEO);
		capture.size(640, 480);
		capture.hide();

		setupFaceDetection()
	}


	async function setupFaceDetection() {
		const model = await faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages
			.mediapipeFacemesh, {
				maxFaces: 4,
				shouldLoadIrisModel: false
			});

		setInterval(async () => {
			predictions = await model.estimateFaces({
				input: capture.elt,
				predictIrises: false
			});
		}, 32)
	}


	function draw() {
		background(255);
		translate(WIDTH, 0);
		scale(-1, 1);
		image(capture, 0, 0, WIDTH, HEIGHT);
		filter(THRESHOLD)
		noStroke()



		for (let i = 0; i < predictions.length; i++) {
			const prediction = predictions[i];
			const grabber = grabbers[i];

			grabber.update(prediction)
			grabber.draw()
		}


		for (const o of objectsToGrab) {
			fill('red')
			ellipse(o.x, o.y, o.r)
		}

		for (const d of dropZones) {
			d.update()
			d.draw()
		}
	}


	function distance(x1, y1, x2, y2) {
		return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
	}
</script>


<style>
	body {
		margin: 0;
	}

	video {
		width: 1080;
		display: none;
	}

	canvas {
		width: 100vw !important;
		height: unset !important;
		image-rendering: pixelated;
	}
</style>